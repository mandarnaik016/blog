---
layout: post
title: Malware Analysis - LNK
subtitle: Shortcut To Death!
cover-img: /assets/img/analysis/analysis.webp
thumbnail-img: ""
tags: [analysis, security]
---

In this post, we will analyze how the **LNK shortcuts** file can be used by threat actors for malicious purposes.

The source of the sample is [Malware Bazaar](https://bazaar.abuse.ch/sample/8ea35c2bfdf4cad1197abadd19f4f0e09579afcfdb32abc7e71bb5818c6d3ba6/).

Let's extract the shortcut to our desktop folder. If given the assumption the file does not have a weird name like a hash in my case or an icon of reputable software like Chrome, it is *barely distinguishable* from other files.

{% include lazyimg.html img_src="../assets/img/analysis/lnk/lowly/lnk-file-on-desktop.jpeg" img_datasrc="../assets/img/analysis/lnk/lnk-file-on-desktop.png" img_alt="lnk file on desktop" %}

A person might try to use the **open file location** option in hope of finding its source, which in turn cannot be held accountable because the LNK file directs towards a file in the system32 folder.

{% include lazyimg.html img_src="../assets/img/analysis/lnk/lowly/open-file-location.jpeg" img_datasrc="../assets/img/analysis/lnk/open-file-location.png" img_alt="open file location" %}

Seeing the properties of the file might be worth an observation. In the below case, you might see a *powershell*. Most obviously, you might have *cmd* instead of powershell and still make the things work.

{% include lazyimg.html img_src="../assets/img/analysis/lnk/lowly/lnk-file-properties.jpeg" img_datasrc="../assets/img/analysis/lnk/lnk-file-properties.png" img_alt="lnk file properties" %}

The target does not have any limit defined, but by architecture, Windows limits it to some extent. If your command is too long, then you might be able to see only clipped commands.

Let's use the file utility to check its type.

{% include lazyimg.html img_src="../assets/img/analysis/lnk/lowly/file-parse.jpeg" img_datasrc="../assets/img/analysis/lnk/file-parse.png" img_alt="file parse" %}

It's worth observing the *hide normal show minimized* at the end of the output.

We are using a utility called **LEcmd** to parse the LNK file.

{% include lazyimg.html img_src="../assets/img/analysis/lnk/lowly/lecmd-lnk-file-parser-output.jpeg" img_datasrc="../assets/img/analysis/lnk/lecmd-lnk-file-parser-output.png" img_alt="lecmd lnk file parser output" %}

The relative path shows the file name that was shown when we used the open file location options.

The arguments show the actual command that will be executed.

We can also see the icon associated with the shortcut.

If you observe precisely, you might notice the names of the actual files have been clipped, i.e., notep\*.exe and msh\*a. The *forfiles* will loop the directory path for the matches of them.

{% include lazyimg.html img_src="../assets/img/analysis/lnk/lowly/forfiles-used-wisely.jpeg" img_datasrc="../assets/img/analysis/lnk/forfiles-used-wisely.png" img_alt="forfiles used wisely" %}

Usually, security analysts use queries to monitor commands that include cmd or PowerShell; the adversary smartly used the forfiles utility to evade any such purpose. You can use this in conjunction with cm\*.exe, powersh\*.exe, or any other combination.

The mshta utility parses the file located at a remote location, in this case, 

~~~
hxxps[://]ctu[.]timeless-tales[.]shop/api/uz/0912545164/CharcoalWharf[.]json
~~~

Then the PowerShell uses the *start process* parameter to execute the parsed file, i.e., CharcoalWharf.json.

{% include lazyimg.html img_src="../assets/img/analysis/lnk/lowly/malicious-remote-file.jpeg" img_datasrc="../assets/img/analysis/lnk/malicious-remote-file.png" img_alt="malicious remote file" %}

Let's check the file type of the parsed file. The file *CharcoalWharf.json* is a PE file with an overlay.

{% include lazyimg.html img_src="../assets/img/analysis/lnk/lowly/charcoalwharf.json-die.jpeg" img_datasrc="../assets/img/analysis/lnk/charcoalwharf.json-die.png" img_alt="charcoalwharf.json die" %}

We use the hash of the file to check whether it has ever been uploaded to Virustotal, and insights from Virustotal might be helpful for further analysis.

{% include lazyimg.html img_src="../assets/img/analysis/lnk/lowly/charcoalwharf.json-vt.jpeg" img_datasrc="../assets/img/analysis/lnk/charcoalwharf.json-vt.png" img_alt="charcoalwharf.json vt" %}

The file has been detected by 33 engines as malicious at the current point in time.

Remember, the PE file containing an overlay is worth examination. We use a tool called *pecheck.py* to extract or differentiate the overlay from the actual file.

~~~
python pecheck.py -g o -D CharcoalWharf.json > CharcoalWharf.json.overlay
 
python pecheck.py -g s -D CharcoalWharf.json > CharcoalWharf.json.strip
~~~

The first command extracts the overlay from the file.

The second command extracts the actual file without overlay.

Let's check the file type of the actual or stripped file using *DIE*.

{% include lazyimg.html img_src="../assets/img/analysis/lnk/lowly/charcoalwharf.json.strip.exe-die.jpeg" img_datasrc="../assets/img/analysis/lnk/charcoalwharf.json.strip.exe-die.png" img_alt="charcoalwharf.json.strip.exe die" %}

We can repeat the same process to search the hash on Virustotal for more intel.

{% include lazyimg.html img_src="../assets/img/analysis/lnk/lowly/charcoalwharf.json.strip.exe-vt.jpeg" img_datasrc="../assets/img/analysis/lnk/charcoalwharf.json.strip.exe-vt.png" img_alt="charcoalwharf.json.strip.exe vt" %}

The file has been detected by 18 engines as malicious at the current point in time.

{% include lazyimg.html img_src="../assets/img/analysis/lnk/lowly/charcoalwharf.json.overlay.exe-die.jpeg" img_datasrc="../assets/img/analysis/lnk/charcoalwharf.json.overlay.exe-die.png" img_alt="charcoalwharf.json.overlay.exe die" %}

Interesting to note that the overlay of the extracted file also has an overlay; we used DIE for this verification.

On Virustotal, the file has been detected by 10 engines.

{% include lazyimg.html img_src="../assets/img/analysis/lnk/lowly/charcoalwharf.json.overlay.exe-vt.jpeg" img_datasrc="../assets/img/analysis/lnk/charcoalwharf.json.overlay.exe-vt.png" img_alt="charcoalwharf.json.overlay.exe vt" %}

Let's extract the overlay of the overlay file using the same utility.

~~~
python pecheck.py -g o -D CharcoalWharf.json.overlay > CharcoalWharf.json.overlay.overlay
~~~

The file *CharcoalWharf.json.overlay.overlay* is a binary file, as shown by DIE.

{% include lazyimg.html img_src="../assets/img/analysis/lnk/lowly/charcoalwharf.json.overlay.overlay.exe-die.jpeg" img_datasrc="../assets/img/analysis/lnk/charcoalwharf.json.overlay.overlay.exe-die.png" img_alt="charcoalwharf.json.overlay.overlay.exe die" %}

On Virustotal, the file was never uploaded; after we uploaded it, we see it was still in any way detected by 1 vendor.

{% include lazyimg.html img_src="../assets/img/analysis/lnk/lowly/charcoalwharf.json.overlay.overlay.exe-vt.jpeg" img_datasrc="../assets/img/analysis/lnk/charcoalwharf.json.overlay.overlay.exe-vt.png" img_alt="charcoalwharf.json.overlay.overlay.exe vt" %}

Upon opening the binary file in NP++, we could interpret it as an **HTA application** by observing the very first line. Also, the presence of MZ magic bytes means the file is executable.

{% include lazyimg.html img_src="../assets/img/analysis/lnk/lowly/charcoalwharf.json.overlay.overlay.exe-hta.jpeg" img_datasrc="../assets/img/analysis/lnk/charcoalwharf.json.overlay.overlay.exe-hta.png" img_alt="charcoalwharf.json.overlay.overlay.exe hta" %}

We meet next time dissecting another sample or coming up with an evasion technique until then. Бааи Баи
